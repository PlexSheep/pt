//! # Compute expressions
//!
//! Compute computations with your computer (`ccc`)
//!
//! This modules aim is to take a term of any kind ([String]) and compute it's value, be it
//! variable based or a concrete numerical value. It implements different operators and
//! (mathematical) functions.

//// ATTRIBUTES ////////////////////////////////////////////////////////////////////////////////////
// we want docs
#![warn(missing_docs)]
#![warn(rustdoc::missing_crate_level_docs)]
// we want Debug everywhere.
#![warn(missing_debug_implementations)]
// enable clippy's extra lints, the pedantic version
#![warn(clippy::pedantic)]

//// IMPORTS ///////////////////////////////////////////////////////////////////////////////////////
pub mod result;
use result::{Error, Result};

use self::result::ComputeResult;
use crate::logger::{trace, debug, info, warn, error};

//// TYPES /////////////////////////////////////////////////////////////////////////////////////////

//// CONSTANTS /////////////////////////////////////////////////////////////////////////////////////

//// STATICS ///////////////////////////////////////////////////////////////////////////////////////

//// MACROS ////////////////////////////////////////////////////////////////////////////////////////

//// ENUMS /////////////////////////////////////////////////////////////////////////////////////////
#[non_exhaustive]
pub enum Constants {
    Pi
}

////////////////////////////////////////////////////////////////////////////////////////////////////
#[non_exhaustive]
pub enum Operations {
    Addit
}

////////////////////////////////////////////////////////////////////////////////////////////////////
#[non_exhaustive]
pub enum Functions {
    Root
}

//// STRUCTS ///////////////////////////////////////////////////////////////////////////////////////
struct Computer;

////////////////////////////////////////////////////////////////////////////////////////////////////
#[derive(Debug)]
struct Term {
    original: String,
    result: Option<ComputeResult>,
    parts: Vec<String>
}

//// IMPLEMENTATION ////////////////////////////////////////////////////////////////////////////////
impl Computer {
    pub fn oneshot(t: String) -> Result<ComputeResult> {
        trace!(orig=t, "parsing original string to Term");
        let mut t = Term::new(t);
        trace!("term has been parsed, starting computation");
        debug!("parsed term: {t:#?}");
        Self::compute(t)
    }

    /// ## compute a [`Term`]
    ///
    /// This method makes use of the 
    /// [shunting yard algorithm](https://en.wikipedia.org/wiki/Shunting_yard_algorithm) to
    /// compute the final value of any term.
    ///
    /// This method only processes a single term at a time, without caching.
    pub fn compute(mut t: Term) -> Result<ComputeResult> {
        trace!("computing term {t:?}");
    }
}

impl Term {
    pub fn new(orig: String) -> Self {
        Term {
            original: orig,
            result: None,
            parts: Vec::new()
        }
    }
}

//// PUBLIC FUNCTIONS //////////////////////////////////////////////////////////////////////////////

//// PRIVATE FUNCTIONS /////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////
